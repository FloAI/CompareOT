suppressPackageStartupMessages({
  require(MASS)
  require(norm)
  require(VIM)
  require(ggplot2)
  require(naniar)
  require(mice)
  require(OTrecod)
})

source('https://raw.githubusercontent.com/R-miss-tastic/website/master/static/how-to/generate/amputation.R')
set.seed(42)

# ------------------------
# Define simulation parameters
# ------------------------
num_samples_list <- c(100, 200, 300, 400, 500, 1000)
perc_missing_list <- c(0.1, 0.5, 0.9)
target_R2_list <- c(0.2, 0.5,0.8, 0.9)
n_reps <- 30  # repetitions per combination

# ------------------------
# Function to perform analysis and calculate precision
# ------------------------
calculate_precision_for_combinations <- function(num_samples, perc_missing, target_R2) {
  
  # Generate covariates using generic variable names X1-X5
  X1 <- rbinom(num_samples, 1, 0.5)  # binary
  X2_raw <- t(rmultinom(num_samples, 1, prob = c(0.3, 0.4, 0.3)))
  X2 <- apply(X2_raw, 1, function(x) c("A","B","Placebo")[which(x==1)])
  
  X3_raw <- t(rmultinom(num_samples, 1, prob = c(0.1,0.2,0.3,0.4)))
  X3 <- apply(X3_raw, 1, function(x) paste0("L", which(x==1)))
  
  X4 <- rbinom(num_samples, 1, 0.5)  # binary
  X5 <- runif(num_samples, 20, 80)   # continuous
  
  # ------------------------
  # Define the true signal
  # ------------------------
  X1_num <- X1
  X2_num <- ifelse(X2=="A",1,ifelse(X2=="B",2,0))
  X3_num <- as.numeric(factor(X3))
  X4_num <- X4
  X5_num <- X5
  
  signal1 <- 20 + 5*X1_num + 10*X2_num + 2*X3_num - 8*X4_num + 0.3*X5_num
  signal2 <- 15 + 4*X1_num + 8*X2_num + 1.5*X3_num- 6*X4_num + 0.25*X5_num 

  
  # Compute sigma for target RÂ²
  sigma <- sqrt(var(signal) * (1/target_R2 - 1))
  
  # Generate continuous outcomes
  Yb1_cont <- signal1 + sigma*rnorm(num_samples)
  Yb2_cont <- signal2 + sigma*rnorm(num_samples)
  
  # Categorize outcomes
  categorize_Yb1 <- function(value) {
    if (is.na(value)) return(NA)
    else if (value < 25) return("[0-25]")
    else if (value < 50) return("[25-50]")
    else if (value < 75) return("[50-75]")
    else return("[75+]")
  }
  
  categorize_Yb2 <- function(value) {
    if (is.na(value)) return(NA)
    else if (value < 30) return("Low")
    else if (value < 60) return("Medium")
    else return("High")
  }
  
  Yb1 <- sapply(Yb1_cont, categorize_Yb1)
  Yb2 <- sapply(Yb2_cont, categorize_Yb2)
  df_true <- data.frame(Yb1, Yb2)
  
  df <- data.frame(X1, X2, X3, X4, X5)
  
  # ------------------------
  # Introduce missingness
  # ------------------------
  missing_mask <- runif(num_samples) < perc_missing
  DB <- ifelse(missing_mask, "A", "B")
  Yb1[DB=="B"] <- NA
  Yb2[DB=="A"] <- NA
  
  df <- cbind(DB, Yb1, Yb2, df)
  df <- df[order(df$DB), ]
  
  df$DB <- as.factor(df$DB)
  df$Yb1 <- as.factor(df$Yb1)
  df$Yb2 <- as.factor(df$Yb2)
  df$X1 <- as.factor(df$X1)
  df$X2 <- as.factor(df$X2)
  df$X3 <- as.factor(df$X3)
  df$X4 <- as.factor(df$X4)
  df$X5 <- as.numeric(df$X5)
  
  df2 <- df[, c("Yb1","Yb2")]
  df2 <- df2[order(as.numeric(rownames(df2))), ]
  
  # ------------------------
  # OTrecod imputation
  # ------------------------
  R_OUTC1 <- OT_joint(df,
                      prox.X = 0.10,
                      convert.num = 8, convert.class = 1,
                      nominal = c(1,4:7), ordinal = 2:3,
                      dist.choice = "H",
                      maxrelax = 0.1,
                      which.DB = "BOTH")
  
  verif_outc1 <- verif_OT(R_OUTC1, group.class=TRUE, ordinal=TRUE, min.neigb=5)
  # print(verif_outc1)
  
  y_imputed <- R_OUTC1$DATA2_OT[, "OTpred"]
  z_imputed <- R_OUTC1$DATA1_OT[, "OTpred"]
  
  df$Yb2[is.na(df$Yb2)] <- z_imputed
  df$Yb1[is.na(df$Yb1)] <- y_imputed
  
  imputated_df <- df[, c("Yb1","Yb2")]
  imputated_df <- imputated_df[order(as.numeric(rownames(imputated_df))), ]
  
  # ------------------------
  # Compute precision
  # ------------------------
  m_mask <- is.na(df2)
  
  calculate_precision <- function(actual, imputed, m_mask) {
    true_positives <- sum(actual[m_mask] == imputed[m_mask], na.rm=TRUE)
    false_positives <- sum(!is.na(imputed[m_mask]) & actual[m_mask] != imputed[m_mask])
    precision <- true_positives / (true_positives + false_positives)
    return(precision)
  }
  
  precision <- calculate_precision(df_true, imputated_df, m_mask)
  return(precision)
}

# ------------------------
# Run simulation for all combinations
# ------------------------
results <- data.frame(
  num_samples = integer(),
  perc_missing = numeric(),
  target_R2 = numeric(),
  mean_precision = numeric(),
  margin_error = numeric()
)

for (num_samples in num_samples_list) {
  for (perc_missing in perc_missing_list) {
    for (R2 in target_R2_list) {
      
      precisions <- numeric()
      
      for (i in 1:n_reps) {
        precision <- tryCatch({
          calculate_precision_for_combinations(num_samples, perc_missing, R2)
        }, error = function(e) {
          message(paste("Error in repetition", i,
                        "for num_samples =", num_samples,
                        "perc_missing =", perc_missing,
                        "R2 =", R2, ":", e$message))
          return(NA)
        })
        precisions <- c(precisions, precision)
      }
      
      precisions_clean <- na.omit(precisions)
      
      if (length(precisions_clean) > 1) {
        mean_prec <- mean(precisions_clean)
        se <- sd(precisions_clean)/sqrt(length(precisions_clean))
        margin_err <- 1.96*se
      } else {
        mean_prec <- NA
        margin_err <- NA
      }
      
      results <- rbind(results, data.frame(
        num_samples = num_samples,
        perc_missing = perc_missing,
        target_R2 = R2,
        mean_precision = mean_prec,
        margin_error = margin_err
      ))
    }
  }
}

print(results)

